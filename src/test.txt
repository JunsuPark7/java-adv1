

특정 스레드의 작업을 중간에 중단하려면?
volatile 키워드는 여러 스레드에서 공유하는 값에 사용하는 키워드


인터럽트 관련.

인터럽트를 사용하면, Waiting, Timed_Waiting 같은 대기 상태의 스레드를 직접 깨워서,
자동하는 Runnable 상태로 만들 수 있다. 앞서 작성한 예제의 작업 중단

참고로 interrupt()를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다.
오직 sleep() 처럼 InterruptedException을 던지는 메서드를 호출 하거나 또는 호출 중일 때 예외가 발생.
예를들어, 위 코드에서 while(true) log(작업중) 일땐 InterruptedException이 발생하지 않음.

work 스레드는 인터럽트 상태가 되었고, 인터럽트 상태이기 때문에 인터럽트 예외가 발생한다.
인터럽트 상태에서 인터럽트 예외가 발생하면 work 스레드는 다시 작동하는 상태가 된다.
따라서 work 스레드의 인터럽트 상태는 종료된다.

work 스레드의 인터럽트 상태가 true로 계속 유지된다는 문제.
앞서 인터럽트 예외가 터진 경우, 스레드의 인터럽트 상태는 false 가 된다.
반면에 isInterrupted() 메서드는 인터럽트의 상태를 변경하지 않는다. 단순히 인터럽트의 상태를 확인만 함.

그래서, 자바에서 인터럽트 예외가 한번 발생하면, 다시 스레드의 인터럽트 상태를 다시 정상으로 돌리는것은 이러한 이유 때문에,
스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하는 문제가 생김.
인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌여두어야함.

자 그걸 방지 하려면 Thread.interrupted()를 사용하면된다.
Thread.interrupted() 를 호출했을 때 스레드가 인터럽트 상태( true )라면, true 를 반환하고, 해당 스레드의
인터럽트 상태를 false 로 변경한다.
자바는 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상( false )으로 돌린다.
스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.

