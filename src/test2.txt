원자적 연산의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미.
즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는
성질을 가지고 있다. 쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻
이다.

volatile은 여러 cpu 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화 되지 않는 문제를 해결할 뿐...
volatile을 사용하면 cpu의 캐시 메모리를 무시하고, 메인 메모리를 직접 사용하도록함.


이 문제는 연산 자체가 나누어져 있기 때문에 발생함.
연산 자체가 나누어진 경우엔 synchronized 블럭, lock 등을 사용해서 안전한 임계 영역을 만들어야함.


AtomicXXX 클래스들은 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공함. 특정 값을 증가하거나 감소해야 하는데
여러 스레드가 해당 값을 공유해야 한다면, AtomicInteger를 사용 하면 된다.
BasicInteger
가장 빠르다.
CPU 캐시를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.
안전한 임계 영역도 없고, volatile 도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.
단일 스레드가 사용하는 경우에 효율적이다.
VolatileInteger
volatile 을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.
안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.
단일 스레드가 사용하기에는 BasicInteger 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.
SyncInteger
synchronized 를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다.
MyAtomicInteger 보다 성능이 느리다.
MyAtomicInteger
자바가 제공하는 AtomicInteger 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다.
성능도 synchronized , Lock(ReentrantLock) 을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.

락 기반 방식의 문제점.
SyncInteger와 같은 클래스는 데이터를 보호하기 위해 락을 사용.
락은 특정 자원ㅇ르 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한함. 락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고,
락이 해제될 때까지 대기해야함.

하드웨어 관점에서 원자적 연산을 허용함.
1. 기대하는 값을 확인.
2. 값을 변경하는 두 연산을 하나로 묶어서 원자적으로 제공함.


