메모리 가시성
실제 메모리의 접근 방식
CPU는 처리 성능을 개선하기 위해 중간에 캐시 메모리라는 것을 사용한다.

main 스레드 -> cpu 코어1 -> 캐시 메모리 -> 메인 메모리.
work 스레드 -> cpu 코어2 -> 캐시 메모리 -> 메인 메모리.

메인 메모리는 cpu 입장에서 보면 거리도 멀고, 속도도 상대적으로 느리다. 대신에 상대적으로 가격이 저렴해서 큰 용량을 쉽게 구성할 수 있다.
cpu 연산은 매우 빠르기 때문에 cpu 연산의 빠른 성능을 따라가려면, cpu 가까이에 매우 빠른 메모리가 필요한데, 이것이 바로 캐시 메모리.
캐시 메모리는 cpu와 가까이 붙어있고, 속도도 매우 빠른 메모리.하지만 상대적으로 가격이 비싸서 큰 용량 구성 하기 어려움


각 스레드가 runFlag 의 값을 사용하면 CPU는 이 값을 효율적으로 처리하기 위해 먼저 runFlag 를 캐시 메
모리에 불러온다.
그리고 이후에는 캐시 메모리에 있는 runFlag 를 사용하게 된다.


여기서 핵심은 캐시 메모리의 runFlag 값만 변한다는 것이다! 메인 메모리에 이 값이 즉시 반영되지 않는다.
main 스레드가 runFlag의 값을 변경해도 CPU코어1이 사용하는 캐시메모리의 runFlag 값만 false로 변경된다.
work 스레드가 사용하는 cpu 코어2의 캐시 메모리의 runFlag 값은 여전히 true 이다.


그렇다면 캐시메모리에 있는 runFlag의 값이 언제 메인 메모리에 반영될까?
이 부분에 대한 정답은 알 수 없다. cpu 설계 방식과 종류의 따라 다르다.
메인 메모리에 반영을 한다고 해도, 문제는 메인 메모리에 반영된 runFlag 값을 work 스레드가 사용하는 캐시 메모리에 다시 불러와야 한다.

메모리 가시성
이처럼 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성 이라고 한다.
이름 그대로 메모리에 변경한 값이 보이는가, 보이지 않는가의 문제이다.


캐시 메모리를 사용하면 cpu 성능을 개선할 수 있다. 하지만 때로는 이런 성능 향상보다는, 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.
해결방안은 아주 단순하다. 성능을 약간 포기하는 대신에, 값을 읽을때, 값을 쓸 때 모두 메인 메모리에 직접 접근하면 된다.

여러 스레드에서 같은 값을 읽고 써야 한다. -> VOLATILE! 단 캐시 메모리를 사용 할때보다 성능이 느려지는 단점.
꼭 필요한곳 사용
