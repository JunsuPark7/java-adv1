Condition condition = lock.newCondition()
Condition은 ReentrantLock을 사용하는 스레드가 대기하는 스레드 대기 공간이다.
lock.newCondition() 메서드를 호출하면 스레드 대기 공간이 만들어짐. Lock(ReentrantLock)의 스레드 대기 공간은 이렇게 만듬

여기서 핵심은 생산자는 소비자를 깨우고, 소비자는 생산자를 깨운다는 점이다

대기1: 락 획득 대기.
Blocked 상태로 락 획득 대기.

synchronized 대기
-대기1 : 락 획득 대기
 Blocked 상태로 락 획득 대기.
 synchronized를 시작할 때 락이 없으면 대기.
 다른 스레드가 synchronized를 빠져나갈 때 대기가 풀리며 락 획득 시도
 -대기2 : wait() 대기
 waiting 상태로 대기
 wait()를 호출 했을 때 스레드 대기 집합에서 대기
 다른 스레드가 notify()를 호출 했을 때 빠져나감!


 자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가짐.
 1. 모니터 락
 2. 락 대기 집합(모니터 락 대기 집합)
 3. 스레드 대기 집합.

 여기서 락 대기 집합이 1차 대기소이고, 스레드 대기 집합이 2차 대기소라고 생각하자. 2차 대기소에 들어간 스레드는 2차, 1차 대기소를 모두 빠져나와야 임계 영역을 수행함.

 synchronized vs ReentrantLock 대기.
 ReentrantLock 도 2가지 단계의 대기 상태가 존재함.
 대기1. 모니터 락 획득 대기.
 자바 객체 내부의 락 대기 집합(모니터 락 대기 집합)에서 관리.  Blocked 상태로 락 획득 대기
 synchronized를 시작할때 락이 없으면 대기함. 다른 스레드가 synchronized를 빠져나갈 때 락을 획득 시도, 락을 획득하면 락 대기 집합을 빠져나감!

 대기2. wait() 대기.
wait() 를 호출 했을 때 자바 객체 내부의 스레드 대기 집합에서 관리
WAITING 상태로 대기
다른 스레드가 notify() 를 호출 했을 때 스레드 대기 집합을 빠져나감


ReentrantLock 획득 대기
- ReentrantLock의 대기 큐에서 관리
- Waiting 상태로 락 획득 대기.
lock.lock()을 호출 했을 때 락이 없으면 대기.


대용량 트래픽 구성 -> 스레드 성능 최적화를 잘해야함.

BlockingQueue
BoundedQueue를 스레드 관점에서 보면 큐가 특정 조건이 만족될 때까지 스레드의 작업을 차단한다.
데이터 추가 차단: 큐가 가득 차면 데이터 추가 작업put()을 시도하는 스레드는 공간이 생길 때까지 차단된다.
데이터 획득 차단: 큐가 비어 있으면 획득 작업take()을 시도하는 스레드는

실무에서 멀티스레드를 사용할 때는 응답성이 중요.












































